"""PDF exporter for RAG Q&A sessions."""

import io
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY, TA_LEFT
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.platypus import (
    BaseDocTemplate,
    Flowable,
    Frame,
    PageBreak,
    PageTemplate,
    Paragraph,
    SimpleDocTemplate,
    Spacer,
    Table,
    TableStyle,
)


class HeaderFooter(Flowable):
    """Custom header and footer for PDF."""
    
    def __init__(self, title: str, timestamp: str):
        Flowable.__init__(self)
        self.title = title
        self.timestamp = timestamp
    
    def draw(self):
        """Draw header and footer."""
        canvas = self.canv
        width, height = A4
        
        # Header
        canvas.setFont("Helvetica-Bold", 12)
        canvas.setFillColor(colors.darkblue)
        canvas.drawString(50, height - 50, self.title)
        
        # Footer
        canvas.setFont("Helvetica", 8)
        canvas.setFillColor(colors.grey)
        canvas.drawRightString(width - 50, 30, f"Generato il {self.timestamp}")
        canvas.drawString(50, 30, "Business Intelligence RAG System")


class PDFExporter:
    """Export RAG Q&A sessions to PDF format."""
    
    def __init__(self):
        """Initialize PDF exporter."""
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_custom_styles(self):
        """Setup custom paragraph styles."""
        # Title style
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=18,
            textColor=colors.darkblue,
            spaceAfter=20,
            alignment=TA_CENTER,
            fontName='Helvetica-Bold'
        ))
        
        # Question style
        self.styles.add(ParagraphStyle(
            name='Question',
            parent=self.styles['Normal'],
            fontSize=14,
            textColor=colors.darkblue,
            fontName='Helvetica-Bold',
            spaceAfter=10,
            spaceBefore=15,
            leftIndent=20
        ))
        
        # Answer style
        self.styles.add(ParagraphStyle(
            name='Answer',
            parent=self.styles['Normal'],
            fontSize=12,
            alignment=TA_JUSTIFY,
            spaceAfter=15,
            leftIndent=20,
            rightIndent=20,
            fontName='Helvetica'
        ))
        
        # Source style
        self.styles.add(ParagraphStyle(
            name='Source',
            parent=self.styles['Normal'],
            fontSize=10,
            textColor=colors.grey,
            spaceAfter=8,
            leftIndent=30,
            fontName='Helvetica-Oblique'
        ))
        
        # Metadata style
        self.styles.add(ParagraphStyle(
            name='Metadata',
            parent=self.styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            spaceAfter=15,
            alignment=TA_CENTER,
            fontName='Helvetica'
        ))
    
    def export_qa_session(
        self,
        question: str,
        answer: str,
        sources: List[Dict[str, Any]],
        metadata: Optional[Dict[str, Any]] = None,
        filename: Optional[str] = None
    ) -> io.BytesIO:
        """Export a single Q&A session to PDF."""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"qa_session_{timestamp}.pdf"
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        story = []
        timestamp_str = datetime.now().strftime("%d/%m/%Y %H:%M")
        
        # Title
        story.append(Paragraph("Sessione Domande e Risposte RAG", self.styles['CustomTitle']))
        story.append(Paragraph(f"Generato il {timestamp_str}", self.styles['Metadata']))
        story.append(Spacer(1, 20))
        
        # Add metadata if available
        if metadata:
            story.append(Paragraph("<b>Informazioni Sessione:</b>", self.styles['Heading2']))
            metadata_data = []
            for key, value in metadata.items():
                metadata_data.append([key.replace('_', ' ').title() + ":", str(value)])
            
            if metadata_data:
                metadata_table = Table(metadata_data, colWidths=[2*inch, 4*inch])
                metadata_table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ]))
                story.append(metadata_table)
                story.append(Spacer(1, 15))
        
        # Question
        story.append(Paragraph("<b>‚ùì Domanda:</b>", self.styles['Question']))
        story.append(Paragraph(self._clean_text(question), self.styles['Answer']))
        story.append(Spacer(1, 10))
        
        # Answer
        story.append(Paragraph("<b>üí° Risposta:</b>", self.styles['Question']))
        story.append(Paragraph(self._clean_text(answer), self.styles['Answer']))
        story.append(Spacer(1, 15))
        
        # Sources
        if sources:
            story.append(Paragraph("<b>üìö Fonti Utilizzate:</b>", self.styles['Question']))
            story.append(Spacer(1, 10))
            
            for i, source in enumerate(sources, 1):
                # Source header
                score = source.get('score', 0)
                source_title = f"<b>Fonte {i}</b> (Rilevanza: {score:.1%})"
                story.append(Paragraph(source_title, self.styles['Source']))
                
                # Source content
                source_text = source.get('text', 'N/A')
                if len(source_text) > 500:
                    source_text = source_text[:500] + "..."
                story.append(Paragraph(self._clean_text(source_text), self.styles['Source']))
                
                # Source metadata
                if source.get('metadata'):
                    source_metadata = source['metadata']
                    metadata_items = []
                    
                    # Key metadata fields
                    for key in ['source', 'page', 'file_type', 'chunk_id']:
                        if key in source_metadata:
                            value = source_metadata[key]
                            metadata_items.append(f"{key.title()}: {value}")
                    
                    if metadata_items:
                        metadata_text = " | ".join(metadata_items)
                        story.append(Paragraph(
                            f"<i>{metadata_text}</i>", 
                            self.styles['Metadata']
                        ))
                
                story.append(Spacer(1, 8))
        
        # Footer information
        story.append(Spacer(1, 20))
        story.append(Paragraph(
            "<i>Questo documento √® stato generato automaticamente dal Sistema di Business Intelligence RAG. "
            "Le informazioni contenute sono basate sui documenti analizzati e sull'intelligenza artificiale.</i>",
            self.styles['Metadata']
        ))
        
        # Build PDF
        doc.build(story)
        buffer.seek(0)
        return buffer
    
    def export_document_analysis(
        self,
        document_analyses: Dict[str, str],
        metadata: Optional[Dict[str, Any]] = None,
        filename: Optional[str] = None
    ) -> io.BytesIO:
        """Export document analysis to PDF."""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"document_analysis_{timestamp}.pdf"
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        story = []
        timestamp_str = datetime.now().strftime("%d/%m/%Y %H:%M")
        
        # Title
        story.append(Paragraph("Analisi Automatica dei Documenti", self.styles['CustomTitle']))
        story.append(Paragraph(f"Generato il {timestamp_str}", self.styles['Metadata']))
        story.append(Spacer(1, 20))
        
        # Add metadata if available
        if metadata:
            story.append(Paragraph("<b>Informazioni Analisi:</b>", self.styles['Heading2']))
            metadata_data = []
            for key, value in metadata.items():
                metadata_data.append([key.replace('_', ' ').title() + ":", str(value)])
            
            if metadata_data:
                metadata_table = Table(metadata_data, colWidths=[2*inch, 4*inch])
                metadata_table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ]))
                story.append(metadata_table)
                story.append(Spacer(1, 15))
        
        # Document analyses
        for i, (file_name, analysis) in enumerate(document_analyses.items(), 1):
            # Document header
            story.append(Paragraph(f"<b>üìÑ Documento {i}: {file_name}</b>", self.styles['Question']))
            story.append(Spacer(1, 10))
            
            # Analysis content
            story.append(Paragraph(self._clean_text(analysis), self.styles['Answer']))
            story.append(Spacer(1, 20))
            
            # Add page break between documents (except for the last one)
            if i < len(document_analyses):
                story.append(PageBreak())
        
        # Summary section
        if len(document_analyses) > 1:
            story.append(PageBreak())
            story.append(Paragraph("<b>üìä Riepilogo</b>", self.styles['Question']))
            story.append(Spacer(1, 10))
            
            summary_data = [["#", "Nome Documento", "Lunghezza Analisi"]]
            for i, (file_name, analysis) in enumerate(document_analyses.items(), 1):
                word_count = len(analysis.split())
                summary_data.append([str(i), file_name, f"{word_count} parole"])
            
            summary_table = Table(summary_data, colWidths=[0.5*inch, 4*inch, 1.5*inch])
            summary_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            story.append(summary_table)
        
        # Footer information
        story.append(Spacer(1, 20))
        story.append(Paragraph(
            "<i>Questo documento contiene le analisi automatiche generate dal Sistema di Business Intelligence RAG. "
            "Le analisi sono basate sul contenuto dei documenti caricati e sull'intelligenza artificiale.</i>",
            self.styles['Metadata']
        ))
        
        # Build PDF
        doc.build(story)
        buffer.seek(0)
        return buffer
    
    def export_multiple_sessions(
        self,
        sessions: List[Dict[str, Any]],
        filename: Optional[str] = None
    ) -> io.BytesIO:
        """Export multiple Q&A sessions to a single PDF."""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"qa_sessions_{timestamp}.pdf"
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72
        )
        
        story = []
        timestamp_str = datetime.now().strftime("%d/%m/%Y %H:%M")
        
        # Title
        story.append(Paragraph("Report Sessioni Domande e Risposte RAG", self.styles['CustomTitle']))
        story.append(Paragraph(f"Generato il {timestamp_str}", self.styles['Metadata']))
        story.append(Spacer(1, 20))
        
        # Summary table
        story.append(Paragraph("<b>Riepilogo Sessioni:</b>", self.styles['Heading2']))
        summary_data = [["#", "Domanda", "Fonti", "Timestamp"]]
        
        for i, session in enumerate(sessions, 1):
            question_preview = session.get('question', '')[:50] + "..." if len(session.get('question', '')) > 50 else session.get('question', '')
            sources_count = len(session.get('sources', []))
            timestamp = session.get('timestamp', 'N/A')
            summary_data.append([str(i), question_preview, str(sources_count), timestamp])
        
        summary_table = Table(summary_data, colWidths=[0.5*inch, 3*inch, 0.8*inch, 1.2*inch])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(summary_table)
        story.append(PageBreak())
        
        # Individual sessions
        for i, session in enumerate(sessions, 1):
            story.append(Paragraph(f"Sessione {i}", self.styles['Heading2']))
            story.append(Spacer(1, 10))
            
            question = session.get('question', 'N/A')
            answer = session.get('answer', 'N/A')
            sources = session.get('sources', [])
            session_metadata = session.get('metadata', {})
            
            # Add timestamp to metadata
            if 'timestamp' in session:
                session_metadata['Timestamp'] = session['timestamp']
            
            # Question
            story.append(Paragraph("<b>‚ùì Domanda:</b>", self.styles['Question']))
            story.append(Paragraph(self._clean_text(question), self.styles['Answer']))
            story.append(Spacer(1, 10))
            
            # Answer
            story.append(Paragraph("<b>üí° Risposta:</b>", self.styles['Question']))
            story.append(Paragraph(self._clean_text(answer), self.styles['Answer']))
            story.append(Spacer(1, 15))
            
            # Sources (abbreviated for multiple sessions)
            if sources:
                story.append(Paragraph(f"<b>üìö Fonti ({len(sources)}):</b>", self.styles['Question']))
                for j, source in enumerate(sources[:3], 1):  # Show only top 3 sources
                    score = source.get('score', 0)
                    source_title = f"Fonte {j} (Rilevanza: {score:.1%})"
                    story.append(Paragraph(source_title, self.styles['Source']))
                    
                    source_text = source.get('text', 'N/A')
                    if len(source_text) > 200:
                        source_text = source_text[:200] + "..."
                    story.append(Paragraph(self._clean_text(source_text), self.styles['Source']))
                
                if len(sources) > 3:
                    story.append(Paragraph(f"<i>... e altre {len(sources) - 3} fonti</i>", self.styles['Metadata']))
            
            if i < len(sessions):  # Add page break except for last session
                story.append(PageBreak())
        
        # Build PDF
        doc.build(story)
        buffer.seek(0)
        return buffer
    
    def _clean_text(self, text: str) -> str:
        """Clean text for PDF generation with robust error handling."""
        if not text:
            return ""
        
        import re
        
        # Remove any existing malformed HTML/XML tags first
        text = re.sub(r'<[^>]*>', '', text)
        
        # Clean up any weird character sequences that might cause issues
        # Remove standalone numbers at line breaks that seem to be artifacts
        text = re.sub(r'\n\d+\n', '\n', text)
        text = re.sub(r'<br/>\d+<br/>', '<br/>', text)
        
        # Remove orphaned single digits that appear to be formatting artifacts
        text = re.sub(r'<br/>\d+(?=\w)', '<br/>', text)  # Remove digits before words
        text = re.sub(r'(?<=\w)\d+<br/>', '<br/>', text)  # Remove digits after words at line end
        text = re.sub(r'<br/>\d+$', '', text, flags=re.MULTILINE)  # Remove trailing digits
        
        # Escape HTML entities first
        text = text.replace('&', '&amp;')
        text = text.replace('<', '&lt;')
        text = text.replace('>', '&gt;')
        
        # Handle markdown-style formatting after escaping
        # Bold: **text** -> <b>text</b>
        text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', text)
        
        # Italic: *text* -> <i>text</i> (but not if it's already processed)
        text = re.sub(r'(?<!<b>)\*([^*]+?)\*(?!</b>)', r'<i>\1</i>', text)
        
        # Handle newlines
        text = text.replace('\n\n', '<br/><br/>')
        text = text.replace('\n', '<br/>')
        
        # More aggressive cleanup of orphaned digits after line breaks are converted
        text = re.sub(r'<br/>\d+(?=[A-Za-z])', '<br/>', text)  # Remove digits before letters
        text = re.sub(r'(?<=[.:])\d+<br/>', '<br/>', text)  # Remove digits after punctuation at line end
        text = re.sub(r'<br/>\d+<br/>\d+', '<br/>', text)  # Remove consecutive digit lines
        text = re.sub(r'<br/>\d+:', '<br/>', text)  # Remove orphaned "number:" patterns
        text = re.sub(r'(?<=\w)\d+(?=\w)', '', text)  # Remove single digits between words
        
        # Clean up multiple consecutive breaks
        text = re.sub(r'(<br/>){3,}', '<br/><br/>', text)
        
        # Final cleanup: ensure all tags are properly formed
        # Remove any malformed tags that might have slipped through
        text = re.sub(r'<b>([^<]*)<b>', r'<b>\1</b>', text)  # Fix unclosed bold
        text = re.sub(r'<i>([^<]*)<i>', r'<i>\1</i>', text)  # Fix unclosed italic
        
        # Remove empty tags
        text = re.sub(r'<b></b>', '', text)
        text = re.sub(r'<i></i>', '', text)
        
        return text.strip()